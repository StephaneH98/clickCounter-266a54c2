name: Dev CI Pipeline Secure 

on:
  push:
    branches: [ dev ]
  workflow_dispatch: 

permissions:
  contents: write
  pull-requests: write  # crÃ©er ou commenter une PR

jobs:
  # Analyse statique
  sast:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Run Semgrep
        id: semgrep
        uses: returntocorp/semgrep-action@v1
        continue-on-error: true

      - name: Run Gitleaks (secrets scan)
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        with:
          args: "--verbose --redact"
        continue-on-error: true


  semantic-versioning:
    runs-on: ubuntu-latest
    needs: sast
    outputs:
      version_type: ${{ steps.determine_version.outputs.VERSION_TYPE }}
      diff_file: ${{ steps.get_diff.outputs.DIFF_FILE }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get list of changed files
        id: get_diff
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD | tr '\n' ' ')
          echo "CHANGED_FILES=$CHANGED_FILES"
          # CrÃ©er un fichier temporaire pour stocker le contenu des diffs
          DIFF_FILE="diff_content.txt"
          > $DIFF_FILE  # CrÃ©e ou vide le fichier

          # RÃ©cupÃ©rer le contenu des diffÃ©rences pour chaque fichier modifiÃ©
          for file in $CHANGED_FILES; do
            echo "Processing file: $file" >> $DIFF_FILE
            git diff origin/main...HEAD -- $file >> $DIFF_FILE
            echo -e "\n\n" >> $DIFF_FILE  # Ajouter une sÃ©paration entre les diffs des fichiers
          done

          echo "Diff content saved to: $DIFF_FILE"
          # Sauvegarder le chemin du fichier dans une variable d'environnement pour l'utiliser dans une Ã©tape suivante
          echo "$(cat diff_content.txt)"
          echo "DIFF_FILE=$DIFF_FILE" >> $GITHUB_ENV
          echo "DIFF_FILE=$(cat diff_content.txt)" >> $GITHUB_OUTPUT

      - name: Determine version type with OpenAI
        id: determine_version
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          AI_SYSTEM_PROMPT: ${{ vars.AI_VERSIONING_SYSTEM_PROMPT }}
          AI_USER_PROMPT: ${{ vars.AI_VERSIONING_USER_PROMPT }}
        run: |
          # Lire le fichier de diffs et envoyer son contenu Ã  Hugging Face
          cat $DIFF_FILE  # Juste pour dÃ©boguer et voir le contenu du fichier

          JSON_PAYLOAD=$(jq -n \
            --arg model "gpt-3.5-turbo" \
            --arg content_system "$AI_SYSTEM_PROMPT" \
            --arg content_user "$AI_USER_PROMPT $DIFF_FILE" \
            '{
              model: $model,
              messages: [
                { role: "system", content: $content_system },
                { role: "user", content: $content_user }
              ],
              temperature: 0
            }'
          )

          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")
          
          echo $RESPONSE
          VERSION_TYPE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')
          echo "VERSION_TYPE=$VERSION_TYPE" >> $GITHUB_ENV
          echo "VERSION_TYPE=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "Version type detected: $VERSION_TYPE"


  # Build et scan image Docker
  docker-scan:
    needs: [sast, semantic-versioning]
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.increment_tag.outputs.NEW_TAG }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get Docker Hub Token
        id: get_token
        env:
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
        run: |
          TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "${{ secrets.DOCKER_HUB_USERNAME }}", "password": "${{ secrets.DOCKER_HUB_TOKEN }}"}' https://hub.docker.com/v2/users/login/ | jq -r .token)
          echo "TOKEN=$(echo "$TOKEN" | tr -d '\n')" >> $GITHUB_ENV
      - name: Get Docker image tags list
        id: get_tags_list
        run: |
          TAG_LIST=$(curl -s -H "Authorization: JWT $TOKEN"   https://hub.docker.com/v2/repositories/stephanehamaili/webapp/tags)
          LATEST_TAG=$(echo "$TAG_LIST" | jq -r '.results | map(.name) | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort | last')
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_TAG"
          echo "MAJOR=$MAJOR" >> $GITHUB_ENV
          echo "MINOR=$MINOR" >> $GITHUB_ENV
          echo "PATCH=$PATCH" >> $GITHUB_ENV

      # ðŸ”¹ IncrÃ©mentation automatique (ex: 1.0.3 â†’ 1.0.4)
      - name: Increment tag
        id: increment_tag
        run: |
          VERSION_TYPE="${{ needs.semantic-versioning.outputs.version_type }}"
          case "$VERSION_TYPE" in
            MAJOR)
              MAJOR=$((${{ env.MAJOR }} + 1))
              MINOR=0
              PATCH=0
              ;;
            MINOR)
              MINOR=$((${{ env.MINOR }} + 1))
              PATCH=0
              ;;
            PATCH)
              PATCH=$((${{ env.PATCH }} + 1))
              ;;
            *)
              echo "Unknown version type"
              exit 1
              ;;
          esac

          echo "MAJOR=$MAJOR" >> $GITHUB_ENV
          echo "MINOR=$MINOR" >> $GITHUB_ENV
          echo "PATCH=$PATCH" >> $GITHUB_ENV

          NEW_TAG="${{ env.MAJOR }}.${{ env.MINOR }}.${{ env.PATCH }}"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

      # ðŸ”¹ Build Docker image avec les nouveaux tags
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }} -t ${{ secrets.DOCKER_HUB_USERNAME }}/webapp:latest ./appOnly/app

      # ðŸ”¹ Scan de l'image avec Trivy
      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }}
          format: 'table'
          output: 'trivy-scan-report.json'
          exit-code: '0'  # Faille => build n'Ã©choue pas. Passer Ã  1 pour que Ã§a Ã©choue en cas de failles
      
      


  # ðŸ”¹ Mise Ã  jour du hash dans le fichier values.yaml du repo helm
  helm-hash-update:
    needs: [docker-scan, semantic-versioning]
    runs-on: ubuntu-latest
    steps:   
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: RÃ©cupÃ©rer les outputs
        id: get_outputs
        run: |
          VERSION_TYPE=${{ needs.semantic-versioning.outputs.version_type }}
          NEW_TAG=${{ needs.docker-scan.outputs.new_tag }}
          echo "VERSION_TYPE=$VERSION_TYPE" >> $GITHUB_ENV
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV

      - name: Cloner le repo Helm
        id: clone_helm_repo
        env:
          GIT_TOKEN_REPO_HELM: ${{ secrets.GIT_TOKEN_REPO_HELM }}
          GIT_USERNAME: ${{ secrets.GIT_USERNAME }}
          HELM_REPOSITORY_NAME: ${{ vars.HELM_REPOSITORY_NAME }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git clone https://x-access-token:${{ env.GIT_TOKEN_REPO_HELM }}@github.com/${{ env.GIT_USERNAME }}/${{ env.HELM_REPOSITORY_NAME }}
          
         
      - name: Generate changelog entry with OpenAI
        id: generate_changelog
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          AI_CHANGELOG_SYSTEM_PROMPT: ${{ vars.AI_CHANGELOG_SYSTEM_PROMPT }}
          AI_CHANGELOG_USER_PROMPT: ${{ vars.AI_CHANGELOG_USER_PROMPT }}
          DIFF_FILE: ${{ needs.semantic-versioning.outputs.diff_file }}
        run: |
            JSON_PAYLOAD=$(jq -n \
              --arg model "gpt-3.5-turbo" \
              --arg content_system "$AI_CHANGELOG_SYSTEM_PROMPT" \
              --arg content_user "$AI_CHANGELOG_USER_PROMPT $(cat $DIFF_FILE)" \
              '{
                model: $model,
                messages: [
                  { role: "system", content: $content_system },
                  { role: "user", content: $content_user }
                ],
                temperature: 0
              }'
            )
  
            RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$JSON_PAYLOAD")
  
            echo "AI_CHANGELOG_SYSTEM_PROMPT: $AI_CHANGELOG_SYSTEM_PROMPT"
            echo "AI_CHANGELOG_USER_PROMPT: $AI_CHANGELOG_USER_PROMPT"
            echo "DIFF_FILE: $(cat $DIFF_FILE)"
            cat $DIFF_FILE
            echo $RESPONSE
            CHANGELOG_LINE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' | sed 's/^/- /')
            echo $CHANGELOG_LINE > changelog_line.txt
            echo "Generated changelog entry: $CHANGELOG_LINE"

      # ðŸ”¹ Connexion Ã  Docker Hub
      - name: Login to Docker Hub
        id: login_docker_hub
        env:
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
        run: |
          echo "${{ env.DOCKER_HUB_TOKEN }}" | docker login -u "${{ env.DOCKER_HUB_USERNAME }}" --password-stdin


      # ðŸ”¹ Build Docker image avec les nouveaux tags
      - name: Build Docker image
        id: build_docker_image
        env:
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          NEW_TAG: ${{ needs.docker-scan.outputs.new_tag }}
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }} -t ${{ secrets.DOCKER_HUB_USERNAME }}/webapp:latest ./appOnly/app

      # ðŸ”¹ Push des images (nouvelle version + latest)
      - name: Push Docker image
        id: push_docker_image
        env:
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          NEW_TAG: ${{ needs.docker-scan.outputs.new_tag }}
        run: |
          docker push ${{ env.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }}
          docker push ${{ env.DOCKER_HUB_USERNAME }}/webapp:latest


      - name: Get image digest
        id: get_digest
        env:
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
        run: |
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }} | cut -d'@' -f2)
          echo "Digest: $DIGEST"
          echo "Digest= $(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_HUB_USERNAME }}/webapp:${{ env.NEW_TAG }})"
          echo "IMAGE_DIGEST=$DIGEST" >> $GITHUB_ENV

      # ðŸ”¹ Update helm chart
      - name: update helm chart
        id: update_helm
        env:
          IMAGE_DIGEST: ${{ env.IMAGE_DIGEST }}
          HELM_REPOSITORY_PATH: ${{ vars.HELM_REPOSITORY_PATH }}
        run: |
          cd ${{ env.HELM_REPOSITORY_PATH }}
          git checkout dev
          sed -i "s|digest:.*|digest: '${{ env.IMAGE_DIGEST }}'|" ./values.yaml
          # cat ./values.yaml | grep digest
          
          git add ./values.yaml
          git commit -m "Update image to ${{ env.IMAGE_DIGEST }} from CI"
          git push origin dev
      - name: Show current commits
        run: git log --oneline --graph --decorate -n 10

      # ðŸ”¹ Update CHANGELOG.md
      - name: Update CHANGELOG.md
        id: update_changelog
        run: |
          DATE=$(date +'%Y-%m-%d')
          echo -e "## [$VERSION_TYPE] - $DATE\n$(cat changelog_line.txt)\n\n$(cat CHANGELOG.md)" > CHANGELOG.md

      # ðŸ”¹ Commit and push changelog
      - name: Commit and push changelog
        id: commit_and_push_changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git pull origin dev
          git add CHANGELOG.md
          git commit -m "chore: update changelog for $VERSION_TYPE release" || echo "No changes to commit"
          git push origin dev

      - name: Set up Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull origin dev

      - name: Check current branch
        id: get_branch
        run: |
          echo "branch=$(git rev-parse --abbrev-ref HEAD)"
          echo "branch=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT

      - name: Push branch to origin if not yet pushed
        run: |
          git push -u origin ${{ steps.get_branch.outputs.branch }} || echo "Already pushed"

      - name: Check if PR already exists
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GIT_ACTIONS_PR_BOT }}
        run: |
          pr_url=$(gh pr list --base main --head dev --state open --json url -q '.[0].url' || echo "")
          echo "PR_URL=$pr_url"
          echo "PR_URL=$pr_url" >> $GITHUB_ENV

      - name: Update PR body
        if: env.PR_URL != ''
        env:
          GH_TOKEN: ${{ secrets.GIT_ACTIONS_PR_BOT }}
        run: |
          gh pr edit "$PR_URL" --body "$(gh pr view "$PR_URL" --json body -q .body)\n\n$(cat changelog_line.txt)"

      - name: Create Pull Request with gh CLI
        if: env.PR_URL == ''
        env:
          GH_TOKEN: ${{ secrets.GIT_ACTIONS_PR_BOT }}
        run: |
          gh pr create \
            --base main \
            --head ${{ steps.get_branch.outputs.branch }} \
            --title "Auto PR from ${{ steps.get_branch.outputs.branch }}" \
            --body "This PR was created automatically via GitHub Actions.
            $(cat changelog_line.txt)"